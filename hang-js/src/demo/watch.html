<!doctype html>
<html lang="en" class="dark">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MoQ Demo</title>
	<link rel="stylesheet" href="index.css">
</head>

<body>
	<div id="container">
		<!-- Include the custom element to set up the canvas. -->
		<hang-watch url="http://localhost:4443" name="demo/bbb" id="watch">
			<!-- Optionally provide a custom canvas element that we can style as needed -->
			<canvas style="max-width: 100%; height: auto; border-radius: 4px;"></canvas>
		</hang-watch>

		<!-- Make some "simple" controls to demonstate the API. -->
		<div style="justify-content: space-between; margin: 8px 0; gap: 8px; display: flex;">
			<button id="pause" title="Pause">
				‚è∏Ô∏è
			</button>

			<span>
				<button id="mute" title="Mute">üîä</button>
				<input type="range" id="volume" min=0 max=1 step=0.01 value=0.5 title="Volume"></input>
				<span id="volume-value">50%</span>
			</span>

			<span id="status">üü° Initializing...</span>

			<span title="Latency">
				‚è≥
				<input type="range" id="latency" min=0 max=4000 step=10 value=50></input>
				<span id="latency-value">50ms</span>
			</span>

			<button id="fullscreen" title="Fullscreen">‚õ∂</button>
		</div>
	</div>

	<h3>Other demos:</h3>
	<ul>
		<li><a href="publish.html">Publish a broadcast.</a></li>
	</ul>

	<h3>Tips:</h3>
	<p>
		Click the video to enable audio.
		This is not always necessary, but sometimes browsers require user interaction before autoplaying
		audio. If using the library directly, call <code class="language-typescript">watch.audio.init()</code> to try
		to reinitialize audio.
	</p>
	<p>
		You can use CSS to change the size of the canvas.
		Unfortunately, you can't use the HTML width/height attributes because of <a
			href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas">OffscreenCanvas</a>
		limitation.

		For example:
	<pre><code class="language-html">&lt;hang-watch url=&quot;http://localhost:4443/&quot; name=&quot;demo/bbb&quot;&gt;
	&lt;!-- Optionally provide a custom canvas element that we can style as needed --&gt;
	&lt;canvas style=&quot;max-width: 100%; height: auto; border-radius: 4px;&quot;&gt;&lt;/canvas&gt;
&lt;/hang-watch&gt;</code></pre>
	</p>
	<p>
		Media only flows over the network when needed!
		Video won't be downloaded when minimized/paused and audio won't be downloaded when muted or disabled.
		This extends to publishing as well, the client won't push media until at least 1 viewer wants it.
	</p>
	<p>
		You can instanciate the player via the provided <code class="language-html">&lt;hang-watch&gt;</code> <a
			href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components">Web Component</a>.
		Either modify HTML attributes like <code class="language-html">&lt;moq-watch paused&gt;</code>
		or access the element's Javascript API:
	<pre><code class="language-typescript">const watch = document.getElementById("watch");
watch.paused = true;
</code></pre>

	And of course you can use the Javascript API directly instead of the Web Component.
	It's a bit more complicated and subject to change, but it gives you raw <code
		class="language-typescript">VideoFrame</code> and <code class="language-typescript">AudioData</code> output.

	</p>
	<p>
		This demo supports query parameters to change the broadcast.
		Try running <code class="language-bash">just pub tos</code> in a new terminal and then <a
			href="?broadcast=demo/tos" target="_blank">watch the
			inferior test video</a>. The player also support automatically reloading broadcasts.
		Try running multiple terminals and kill the broadcast to see what happens.

	<pre><code class="language-bash"># Run the relay and web server in another terminal or the background.
just relay &
just web &

just pub bbb
# Kill it with ctrl+C

# Republish the same broadcast, the player will reconnect.
just pub bbb
		</code></pre>
	</p>
</body>

<script>
	// Yes this is a terrible mess and not how we make websites in >current year<.
	// But this is a demo and I don't feel like making it more complicated via React.
	const watch = document.getElementById("watch");
	const pause = document.getElementById("pause");
	const fullscreen = document.getElementById("fullscreen");
	const status = document.getElementById("status");
	const volume = document.getElementById("volume");
	const container = document.getElementById("container");
	const latency = document.getElementById("latency");
	const latencyValue = document.getElementById("latency-value");
	const volumeValue = document.getElementById("volume-value");
	const mute = document.getElementById("mute");

	// If query params are provided, use them as the broadcast URL instead of the default.
	const urlParams = new URLSearchParams(window.location.search);
	if (urlParams.size > 0) {
		const broadcast = urlParams.get("name") ?? "demo/bbb";
		const host = urlParams.get("host") ?? "localhost:4443";
		const scheme = urlParams.get("scheme") ?? "http";
		watch.setAttribute("url", `${scheme}://${host}`);
		watch.setAttribute("name", broadcast);
	}

	// Listen for clicks on the pause button.
	pause.addEventListener("click", () => {
		watch.video.paused = !watch.video.paused;
		watch.audio.paused = watch.video.paused;

		if (watch.video.paused) {
			pause.textContent = "‚ñ∂Ô∏è";
		} else {
			pause.textContent = "‚è∏Ô∏è";
		}
	});

	// Listen for clicks on the mute button.
	mute.addEventListener("click", () => {
		watch.audio.muted = !watch.audio.muted;

		if (watch.audio.muted) {
			mute.textContent = "üîá";
			volume.value = 0;
			volumeValue.textContent = "0%";
		} else {
			mute.textContent = "üîä";
			volume.value = watch.audio.volume;
			volumeValue.textContent = `${(watch.audio.volume * 100).toFixed(0)}%`;
		}
	});

	// Listen for clicks on the fullscreen button.
	let fullscreenActive = false;
	fullscreen.addEventListener("click", () => {
		if (fullscreenActive) {
			document.exitFullscreen();
		} else {
			container.requestFullscreen();
		}

		fullscreenActive = !fullscreenActive;
	});

	// Listen for changes to the volume input.
	volume.addEventListener("input", () => {
		if (watch.audio.muted) {
			mute.textContent = "üîä";
			watch.audio.muted = false;
		}

		watch.audio.volume = Number.parseFloat(volume.value);
		volumeValue.textContent = `${(volume.value * 100).toFixed(0)}%`;

		if (volume.value === 0) {
			mute.textContent = "üîá";
		}
	});

	// Listen for connection status changes.
	watch.addEventListener("hang-watch-connection", (event) => {
		if (event.detail === "connected") {
			status.textContent = "üü¢ Connected";
		} else if (event.detail === "connecting") {
			status.textContent = "üü° Connecting...";
		} else if (event.detail === "disconnected") {
			status.textContent = "üî¥ Disconnected";
		} else {
			throw new Error(`Unknown connection status: ${event.detail}`);
		}
	});

	// Listen for changes to the latency input.
	latency.addEventListener("input", () => {
		watch.audio.latency = Number.parseInt(latency.value);
		watch.video.latency = Number.parseInt(latency.value);
		latencyValue.textContent = `${latency.value}ms`;
	});

	// Optional: Stop downloading video when the page is hidden.
	document.addEventListener("visibilitychange", () => {
		watch.video.paused = document.visibilityState === "hidden";

		if (watch.video.paused) {
			pause.textContent = "‚ñ∂Ô∏è";
		} else {
			pause.textContent = "‚è∏Ô∏è";
		}
	});
</script>

</html>